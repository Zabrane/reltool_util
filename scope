#!/usr/bin/env escript
%%!
%%% -*- coding: utf-8; Mode: erlang; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
%%% ex: set softtabstop=4 tabstop=4 shiftwidth=4 expandtab fileencoding=utf-8:
%%%
%%%------------------------------------------------------------------------
%%% BSD LICENSE
%%% 
%%% Copyright (c) 2013, Michael Truog <mjtruog at gmail dot com>
%%% All rights reserved.
%%% 
%%% Redistribution and use in source and binary forms, with or without
%%% modification, are permitted provided that the following conditions are met:
%%% 
%%%     * Redistributions of source code must retain the above copyright
%%%       notice, this list of conditions and the following disclaimer.
%%%     * Redistributions in binary form must reproduce the above copyright
%%%       notice, this list of conditions and the following disclaimer in
%%%       the documentation and/or other materials provided with the
%%%       distribution.
%%%     * All advertising materials mentioning features or use of this
%%%       software must display the following acknowledgment:
%%%         This product includes software developed by Michael Truog
%%%     * The name of the author may not be used to endorse or promote
%%%       products derived from this software without specific prior
%%%       written permission
%%% 
%%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
%%% CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
%%% INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
%%% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
%%% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
%%% CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
%%% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
%%% BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
%%% SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%%% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
%%% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
%%% NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
%%% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
%%% DAMAGE.
%%%------------------------------------------------------------------------

-author('mjtruog [at] gmail (dot) com').

-mode(compile).

-record(config,
        {
            directories_in = [],
            prefix_ignore = undefined,
            prefix_scope = undefined,
            directory_suffix_old = undefined,
            help = false,
            undo = false
        }).

-record(state,
        {
            files_source = [],
            files_applications = [],
            name_conversions = []
        }).

main(Arguments) ->
    handle_operation(parse_command_line(Arguments)).

handle_operation(#config{help = true}) ->
    help(),
    erlang:halt(1);
handle_operation(#config{directories_in = DirectoriesIn,
                         prefix_ignore = PrefixIgnore,
                         prefix_scope = PrefixScope,
                         directory_suffix_old = DirectorySuffixOld,
                         undo = true})
    when DirectoriesIn /= [], is_list(PrefixIgnore), is_list(PrefixScope),
         is_list(DirectorySuffixOld) ->
    ok = undo_mv_old(DirectoriesIn, DirectorySuffixOld),
    ok = undo_rm_scope(DirectoriesIn, PrefixScope),
    erlang:halt(0);
handle_operation(#config{directories_in = DirectoriesIn,
                         prefix_ignore = PrefixIgnore,
                         prefix_scope = PrefixScope,
                         directory_suffix_old = DirectorySuffixOld,
                         undo = false})
    when DirectoriesIn /= [], is_list(PrefixIgnore), is_list(PrefixScope),
         is_list(DirectorySuffixOld) ->
    #state{files_source = FilesSource,
           files_applications = FilesApplications,
           name_conversions = NameConversions} = files_find(DirectoriesIn,
                                                            PrefixIgnore,
                                                            PrefixScope),
    if
        NameConversions == [] ->
            io:format("no files to process!~n", []),
            erlang:halt(1);
        true ->
            ok
    end,
%XXX
%io:format("~p~n", [    #state{files_source = FilesSource,
%               files_applications = FilesApplications,
%                          name_conversions = NameConversions}]),
    _NewSourceFilePaths = igor:rename(FilesSource, NameConversions,
                                      [{stubs, false},
                                       {backups, false}]),
    ok = files_move_old(FilesSource, DirectorySuffixOld),
    ok = files_rename_apps(FilesApplications,
                           orddict:from_list(NameConversions)),
    ok = files_move_old(FilesApplications, DirectorySuffixOld),
    erlang:halt(0).

undo_mv_old([], _) ->
    ok;
undo_mv_old([Directory | DirectoriesIn], DirectorySuffixOld) ->
    true = filelib:is_dir(Directory),
    OldDirectory = Directory ++ DirectorySuffixOld,
    case filelib:is_dir(OldDirectory) of
        true ->
            {ok, FilePaths} = file:list_dir_all(OldDirectory),
            ok = undo_mv_old_dir(FilePaths, OldDirectory, Directory),
            ok = file:del_dir(OldDirectory),
            ok;
        false ->
            ok
    end,
    undo_mv_old(DirectoriesIn, DirectorySuffixOld).

undo_mv_old_dir([], _, _) ->
    ok;
undo_mv_old_dir([FilePath | FilePaths], OldDirectory, Directory) ->
    OldFilePath = filename:join(OldDirectory, FilePath),
    NewFilePath = filename:join(Directory, FilePath),
    ok = file:rename(OldFilePath, NewFilePath),
    undo_mv_old_dir(FilePaths, OldDirectory, Directory).

undo_rm_scope([], _) ->
    ok;
undo_rm_scope([Directory | DirectoriesIn], PrefixScope) ->
    true = filelib:is_dir(Directory),
    {ok, FilePaths} = file:list_dir_all(Directory),
    ok = undo_rm_scope_dir(FilePaths, Directory, PrefixScope),
    undo_rm_scope(DirectoriesIn, PrefixScope).

undo_rm_scope_dir([], _, _) ->
    ok;
undo_rm_scope_dir([FilePath | FilePaths], Directory, PrefixScope) ->
    case lists:prefix(PrefixScope, FilePath) of
        true ->
            FullFilePath = filename:join(Directory, FilePath),
            ok = file:delete(FullFilePath);
        false ->
            ok
    end,
    undo_rm_scope_dir(FilePaths, Directory, PrefixScope).

files_find(DirectoriesIn,
           PrefixIgnore, PrefixScope) ->
    files_find(DirectoriesIn,
               PrefixIgnore, PrefixScope, #state{}).
    
files_find([], _, _,
           #state{files_source = FilesSource,
                  files_applications = FilesApplications,
                  name_conversions = NameConversions} = State) ->
    State#state{files_source = lists:reverse(FilesSource),
                files_applications = lists:reverse(FilesApplications),
                name_conversions = lists:reverse(NameConversions)};
           
files_find([Directory | DirectoriesIn], PrefixIgnore, PrefixScope, State) ->
    true = filelib:is_dir(Directory),
    {ok, FilePaths} = file:list_dir_all(Directory),
    NextState = files_find_dir(FilePaths, Directory,
                               PrefixIgnore, PrefixScope, State),
    files_find(DirectoriesIn, PrefixIgnore, PrefixScope, NextState).

files_find_dir([], _, _, _, State) ->
    State;
files_find_dir([FilePath | FilePaths], Directory, PrefixIgnore, PrefixScope,
               #state{files_source = FilesSource,
                      files_applications = FilesApplications,
                      name_conversions = NameConversions} = State) ->
    FileExtension = filename:extension(FilePath),
    FileName = filename:basename(FilePath, FileExtension),
    ApplicationFile = if
        FileExtension == ".app" ->
            true;
        FileExtension == ".src" ->
            filename:extension(FileName) == ".app";
        true ->
            false
    end,
    SourceFile = if
        ApplicationFile ->
            false;
        FileExtension == ".erl" ->
            true;
        true ->
            false
    end,
    NextState = if
        ApplicationFile ->
            case lists:prefix(PrefixIgnore, FileName) of
                true ->
                    State;
                false ->
                    case lists:prefix(PrefixScope, FileName) of
                        true ->
                            State;
                        false ->
                            BaseFileName = if
                                FileExtension == ".src" ->
                                    filename:basename(FileName, ".app");
                                true ->
                                    FileName
                            end,
                            FullFilePath = filename:join(Directory, FilePath),
                            Convert = {erlang:list_to_atom(BaseFileName),
                                       erlang:list_to_atom(PrefixScope ++
                                                           BaseFileName)},
                            State#state{
                                files_applications = [FullFilePath |
                                                      FilesApplications],
                                name_conversions =
                                    lists:umerge(NameConversions, [Convert])}
                    end
            end;
        SourceFile ->
            case lists:prefix(PrefixIgnore, FileName) of
                true ->
                    State;
                false ->
                    case lists:prefix(PrefixScope, FileName) of
                        true ->
                            State;
                        false ->
                            FullFilePath = filename:join(Directory, FilePath),
                            Convert = {erlang:list_to_atom(FileName),
                                       erlang:list_to_atom(PrefixScope ++
                                                           FileName)},
                            State#state{
                                files_source = [FullFilePath |
                                                FilesSource],
                                name_conversions =
                                    lists:umerge(NameConversions, [Convert])}
                    end
            end;
        true ->
            State
    end,
    files_find_dir(FilePaths, Directory, PrefixIgnore, PrefixScope, NextState).

files_rename_apps([], _) ->
    ok;
files_rename_apps([FilePath | FileApplications], NameLookup) ->
    FileExtension = filename:extension(FilePath),
    FileName = filename:basename(FilePath, FileExtension),
    ApplicationNameStr0 = if
        FileExtension == ".app" ->
            FileName;
        FileExtension == ".src" ->
            filename:basename(FileName, ".app")
    end,
    {ok, [{application,
           ApplicationName,
           ApplicationEnv0}]} = file:consult(FilePath),
    ApplicationNameStr1 = erlang:atom_to_list(ApplicationName),
    true = (ApplicationNameStr0 == ApplicationNameStr1),
    NewApplicationName = orddict:fetch(ApplicationName, NameLookup),
    {value,
     {modules, ModulesList},
     ApplicationEnv1} = lists:keytake(modules, 1, ApplicationEnv0),
    NewModulesList = lists:map(fun(M) ->
        % all source file directories must have been provided
        orddict:fetch(M, NameLookup)
    end, ModulesList),
    ApplicationEnv2 = [{modules, NewModulesList} | ApplicationEnv1],
    ApplicationEnv4 = case lists:keytake(mod, 1, ApplicationEnv2) of
        false ->
            ApplicationEnv2;
        {value,
         {mod, {ApplicationModule, ApplicationModuleList}}, ApplicationEnv3} ->
            NewApplicationModule = orddict:fetch(ApplicationModule, NameLookup),
            [{mod, {NewApplicationModule,
                    ApplicationModuleList}} | ApplicationEnv3]
    end,
    ApplicationEnv6 = case lists:keytake(registered, 1, ApplicationEnv4) of
        false ->
            ApplicationEnv4;
        {value, {registered, RegisteredNames}, ApplicationEnv5} ->
            NewRegisteredNames = lists:map(fun(M) ->
                case orddict:find(M, NameLookup) of
                    {ok, NewM} ->
                        NewM;
                    error ->
                        M
                end
            end, RegisteredNames),
            [{registered, NewRegisteredNames} | ApplicationEnv5]
    end,
    ApplicationEnv8 = case lists:keytake(applications, 1, ApplicationEnv6) of
        false ->
            ApplicationEnv6;
        {value, {applications, ApplicationNames}, ApplicationEnv7} ->
            NewApplicationNames = lists:map(fun(M) ->
                case orddict:find(M, NameLookup) of
                    {ok, NewM} ->
                        NewM;
                    error ->
                        M
                end
            end, ApplicationNames),
            [{applications, NewApplicationNames} | ApplicationEnv7]
    end,
    NewFileName = if
        FileExtension == ".app" ->
            erlang:atom_to_list(NewApplicationName) ++ ".app";
        FileExtension == ".src" ->
            erlang:atom_to_list(NewApplicationName) ++ ".app.src"
    end,
    NewFilePath = filename:join(filename:dirname(FilePath), NewFileName),
    ok = file:write_file(NewFilePath, 
                         io_lib:format("~p.~n",
                                       [{application,
                                         NewApplicationName,
                                         ApplicationEnv8}])),
    files_rename_apps(FileApplications, NameLookup).

files_move_old([], _) ->
    ok;
files_move_old([FilePath | FilePaths], DirectorySuffixOld) ->
    Directory = filename:dirname(FilePath),
    NewDirectory = Directory ++ DirectorySuffixOld,
    case filelib:is_dir(NewDirectory) of
        true ->
            ok;
        false ->
            ok = file:make_dir(NewDirectory)
    end,
    NewFilePath = filename:join(NewDirectory, filename:basename(FilePath)),
    ok = file:rename(FilePath, NewFilePath),
    files_move_old(FilePaths, DirectorySuffixOld).

help() ->
    io:format(
"Usage: ~s [OPTION]~n"
"~n"
"    -d DIR           Source directory of an application for input files~n"
"    -s SCOPE         Scope to apply~n"
"    -i SCOPE         Scope to ignore~n"
"    -b SUFFIX        Set the subdirectory name suffix for file backups~n"
"    -u               Undo the scope operation~n"
"    -h               Display command line options (as shown here)~n"
"~n"
" Note: When processed files are moved to the application source directory~n"
"       with the old suffix (-b option), it is possible an older file will~n"
"       be silently clobbered~n"
,
        [escript:script_name()]).

parse_command_line(Arguments) ->
    Config0 = parse_command_line(Arguments, #config{}),
    Config1 = if
        Config0#config.prefix_ignore =:= undefined ->
            Config0#config{prefix_ignore = Config0#config.prefix_scope};
        Config0#config.prefix_scope =:= undefined ->
            Config0#config{prefix_scope = Config0#config.prefix_ignore};
        true ->
            Config0
    end,
    Config2 = if
        Config1#config.directory_suffix_old =:= undefined ->
            Config1#config{directory_suffix_old = "_old"};
        true ->
            Config1
    end,
    Config3 = Config2#config{
        directories_in = lists:reverse(Config2#config.directories_in)},
    Config3.

parse_command_line([], Config) ->
    Config;
parse_command_line(["-d", Directory | Arguments],
                   #config{directories_in = Directories} = Config) ->
    NewConfig = Config#config{directories_in = [Directory | Directories]},
    parse_command_line(Arguments, NewConfig);
parse_command_line(["-p", PrefixIgnore | Arguments],
                   #config{prefix_ignore = undefined} = Config) ->
    NewConfig = Config#config{prefix_ignore = PrefixIgnore},
    parse_command_line(Arguments, NewConfig);
parse_command_line(["-s", PrefixScope | Arguments],
                   #config{prefix_scope = undefined} = Config) ->
    NewConfig = Config#config{prefix_scope = PrefixScope},
    parse_command_line(Arguments, NewConfig);
parse_command_line(["-b", DirectorySuffixOld | Arguments],
                   #config{directory_suffix_old = undefined} = Config) ->
    NewConfig = Config#config{directory_suffix_old = DirectorySuffixOld},
    parse_command_line(Arguments, NewConfig);
parse_command_line(["-u" | Arguments], Config) ->
    NewConfig = Config#config{undo = true},
    parse_command_line(Arguments, NewConfig);
parse_command_line(["-h" | Arguments], Config) ->
    NewConfig = Config#config{help = true},
    parse_command_line(Arguments, NewConfig);
parse_command_line([Unknown | _], _) ->
    erlang:exit({badarg, {command_line, Unknown}}).

